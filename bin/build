#!/usr/bin/env python

import sys
if sys.version_info < (3, 0):
    reload(sys)
    sys.setdefaultencoding('utf8')
import argparse
import distutils.dir_util as dir_util
import json
import os
import platform
import subprocess
import sys
import textwrap
import timeit
from collections import OrderedDict

sys.path.append(os.path.abspath(os.path.dirname(os.path.realpath(__file__)) + '/../lib'))
import ela_plugin
# import ela_xml

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

#####################
### SCRIPT PARAMS ###
#####################

parser = argparse.ArgumentParser(description='Build the Elastor.Trinity project.',
                                 formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('target', metavar='TARGET', choices=['app', 'all', 'clean', 'clobber', 'cordova', 'plugin'],
                    help=textwrap.dedent('''\
                         Specify the target to build.
                         app: build app;
                         all: build app and cordova;
                         clean: delete platforms and plugins;
                         clobber: delete all build files;
                         cordova: cordova prepare and build;
                         plugin: reintall the specify plugin;
                     '''))
parser.add_argument('-p', '--path', dest='target_path', metavar='PATH', required=False,
                    help='Specify the path/name of plugin/Dapp.')
parser.add_argument('--delete', action='store_true', help='Delete the dapp.')
parser.add_argument('-pf', '--platform', nargs='+', dest='platform', required=False,
                    help='Specify the build platform.')

parser.add_argument('-bt', '--buildtype', dest='buildtype', required=False,
                    help='Specify the build type, elastOS or native, default is elastOS.')
parser.add_argument('-bv', '--buildvariant', dest='buildvariant', required=False,
                    help='Specify the build variant.')

parser.add_argument('--build', action='store_true', help='build project')
parser.add_argument('--release', action='store_true', help='build release')
parser.add_argument('--buildarg', dest='buildarg', required=False,
                    help='Specify the build arg.')
parser.add_argument('--appscopyonly', action='store_true', help='copy app without build app')
parser.add_argument('--skippodupdate', action='store_true', help='Do no call \'pod repo update\'')
parser.add_argument('--uploadsourcemap', action='store_true', help='upload source map to sentry')
args = parser.parse_args()
if args.release:
    build_type='--release'
else:
    build_type=''

if args.platform:
    if 'all' in args.platform:
        build_platform=['android', 'ios', 'electron']
    else:
        build_platform=args.platform
else:
    build_platform= ['android', 'ios']

if args.buildarg:
    build_arg=args.buildarg
else:
    build_arg=''

if args.appscopyonly:
    build_apps=False
else:
    build_apps=True

SCRIPT_PATH=os.path.realpath(__file__)
TOOLCHAINS_DIR_PATH=os.path.dirname(os.path.dirname(SCRIPT_PATH))
TOOLCHAINS_DIR_NAME=os.path.basename(TOOLCHAINS_DIR_PATH)
PROJECT_DIR_PATH=os.path.join(TOOLCHAINS_DIR_PATH, "..")
APP_DIR_PATH=os.path.join(PROJECT_DIR_PATH, "App")
PLUGIN_DIR_PATH=os.path.join(PROJECT_DIR_PATH, "Plugins")
WWW_MIRROR_ANDROID=os.path.join(APP_DIR_PATH, "platforms/android/app/src/main/assets/www/")
WWW_MIRROR_IOS=os.path.join(APP_DIR_PATH, "platforms/ios/www/")
WWW_MIRROR_ELECTRON=os.path.join(APP_DIR_PATH, "platforms/electron/www/")


###############
### METHODS ###
###############

def isWindows():
    return sys.platform == "win32"

def print_with_color(color, message):
    print(color + message + bcolors.ENDC)

def run_cmd(cmd, ignore_error=False):
    print("Running: " + cmd)
    ret = subprocess.call(cmd, shell=True)
    if not ignore_error and ret != 0:
        print_with_color(bcolors.FAIL, "Fail to: " + cmd)
        sys.exit(ret)

def remove_tree(directory):
    print("Removing: " + directory)
    if os.path.isdir(directory):
        dir_util.remove_tree(directory)

def copy_tree(src, dst, clean=True):
    print("Copying " + src + " To " + dst)
    if clean:
        remove_tree(dst)
    if os.path.isdir(src):
        dir_util.copy_tree(src, dst)
    else:
        print_with_color(bcolors.FAIL, "Copy error:" + src + " is not a directory.")

# def get_appid(manifest):
#     file_in = open(manifest, "r")
#     data = json.load(file_in)
#     return data['id']

# build app and copy the www/*
def build_app(app_path, needBuild, output="www"):
    print_with_color(bcolors.OKCYAN, "\r\n-------------------- Building APP --------------------")
    os.chdir(app_path)

    if needBuild:
        run_cmd("npm install")
        if ela_plugin.isWindows():
            run_cmd("set NODE_OPTIONS=--max-old-space-size=4092")
            run_cmd("ionic build --prod")
        else:
            run_cmd("NODE_OPTIONS=--max-old-space-size=4092 ionic build --prod")

    if os.path.isdir(WWW_MIRROR_ANDROID):
        copy_tree(output, WWW_MIRROR_ANDROID)
    if os.path.isdir(WWW_MIRROR_IOS):
        copy_tree(output, WWW_MIRROR_IOS)
    if os.path.isdir(WWW_MIRROR_ELECTRON):
        copy_tree(output, WWW_MIRROR_ELECTRON)

def add_firebase():
    if not os.path.isfile(os.path.join(APP_DIR_PATH + '/GoogleService-Info.plist')):
        print_with_color(bcolors.WARNING, "Can not find GoogleService-Info.plist!")
        return
    if not os.path.isfile(os.path.join(APP_DIR_PATH + '/google-services.json')):
        print_with_color(bcolors.WARNING, "Can not find google-services.json!")
        return

    # the version 10.1.0-cli will check pod in ubuntu, can't add cordova-plugin-firebasex for ios
    # 9.1.2-cli is ok
    sys = platform.system()
    if sys != "Darwin":
        run_cmd("cordova platform rm ios")

    run_cmd("npm install -g xml-js")

    cmd="cordova plugin add cordova-plugin-firebasex"
    run_cmd(cmd)

# def load_partnerapps():
#     config_path = os.path.join(os.path.dirname(SCRIPT_PATH), "partners.json")
#     with open(config_path,'r') as load_f:
#         partnerapps_dict = json.load(load_f)
#         apps_path = partnerapps_dict['dapppath']
#         if apps_path.strip() == "":
#             apps_path = "Dapps/Partner"
#         apps_fullpath = os.path.join(PROJECT_DIR_PATH, apps_path)
#         partnerapps_dict['apps_fullpath'] = apps_fullpath

#         if not os.path.isdir(apps_fullpath):
#             os.makedirs(apps_fullpath)
#         return partnerapps_dict

# def show_partnerapps():
#     partnerapps_dict = load_partnerapps()
#     print("  All partner apps:")
#     for app in partnerapps_dict['partnerapps']:
#         print("    " + app['name'])

# def get_code(app):
#     print("Get the code: " + app['name'])
#     if os.path.isdir(app['name']):
#         os.chdir(app['name'])
#         run_cmd("git checkout master")
#         run_cmd("git pull")
#     else:
#         run_cmd("git clone " + app['repourl'] + " " + app['name'])
#         os.chdir(app['name'])

#     if app['commit'].strip() != "":
#         run_cmd("git checkout " + app['commit'])
#     elif app['tag'].strip() != "":
#         run_cmd("git fetch --tag")
#         run_cmd("git checkout " + app['tag'])

# # Get the code of the partner app and build
# def build_partnerapp(apps_fullpath, app, platform):
#     os.chdir(apps_fullpath)

#     app_fullpath = os.path.join(apps_fullpath, app['name'])
#     if "folder" in app:
#         app_fullpath = os.path.join(app_fullpath, app['folder'])

#     if args.delete:
#         return delete_app(app_fullpath)
#     else:
#         get_code(app)

#         needBuild = True
#         output = "www"

#         if "outputPath" in app:
#             # don't build, just copy
#             needBuild = False
#             output = app['outputPath']

#         build_app(app_fullpath, platform, needBuild, output)

# # Get the code of all partner apps and build
# def build_partnerapps(platform):
#     partnerapps_dict = load_partnerapps()
#     apps_fullpath = partnerapps_dict['apps_fullpath']

#     for app in partnerapps_dict['partnerapps']:
#         if platform in app['platforms']:
#             build_partnerapp(apps_fullpath, app, platform)

# def delete_partnerapps():
#     partnerapps_dict = load_partnerapps()
#     apps_fullpath = partnerapps_dict['apps_fullpath']

#     for app in partnerapps_dict['partnerapps']:
#         app_fullpath = os.path.join(apps_fullpath, app['name'])
#         if "folder" in app:
#             app_fullpath = os.path.join(app_fullpath, app['folder'])
#         delete_app(app_fullpath)

# def updateJsonFile(jsonfile, key, value):
#     file_in = open(jsonfile, "r")
#     data = json.load(file_in, object_pairs_hook=OrderedDict)
#     file_in.close()

#     data[key] = value

#     file_out = open(jsonfile, 'w')
#     file_out.write(json.dumps(data, indent=4))
#     file_out.close()

# def updateConfigFile(key, value):
#     config_path = os.path.join(RUNTIME_DIR_PATH, "www/config/config.json")
#     updateJsonFile(config_path, key, value)

#     # update mirror config file
#     if os.path.isfile(CONFIG_MIRROR_ANDROID):
#         updateJsonFile(CONFIG_MIRROR_ANDROID, key, value)
#     if os.path.isfile(CONFIG_MIRROR_IOS):
#         updateJsonFile(CONFIG_MIRROR_IOS, key, value)

# def updateConfig():
#     if args.buildtype:
#         updateConfigFile("build.type", args.buildtype)
#     if args.buildvariant:
#         updateConfigFile("build.variant", args.buildvariant)

# def updatePackageJson(path, platforms):
#     file_in = open(path, "r")
#     data = json.load(file_in, object_pairs_hook=OrderedDict)
#     data['cordova']['platforms'] = platforms
#     file_in.close()

#     file_out = open(path, 'w')
#     file_out.write(json.dumps(data, indent=2))
#     file_out.close()

def clean_cordova():
    os.chdir(APP_DIR_PATH)
    if isWindows():
        run_cmd("rd package-lock.json", True)
    else:
        run_cmd("rm package-lock.json", True)
    remove_tree("platforms")
    remove_tree("plugins")

startTime = timeit.default_timer()

ela_plugin.setup_paths(APP_DIR_PATH, PLUGIN_DIR_PATH)

# if TOOLCHAINS_DIR_NAME != "ToolChains" or \
#    not os.path.isdir(RUNTIME_DIR_PATH) or \
#    not os.path.isdir(LAUNCHER_DIR_PATH):
#     print_with_color(bcolors.FAIL, 'Error: You should "git clone" the "Elastos.Trinity" project with "--recurse-submodules" option.')
#     print_with_color(bcolors.FAIL, '       And run the script within the "ToolChains/bin" directory of the project.')
#     sys.exit(1)

if args.target == "clean":
    clean_cordova()

if args.target == "clobber":
    os.chdir(APP_DIR_PATH)
    remove_tree("node_modules")
    remove_tree("www")
    clean_cordova()

if args.target == "plugin":
    if args.target_path == None:
        print_with_color(bcolors.FAIL, "You can specify the plugin path: build plugin -p pluginPath")
        ela_plugin.plugin_prepare(True)
        exit(0)
    ela_plugin.re_install_plugin(os.path.join(PROJECT_DIR_PATH, args.target_path))

if args.target == "all" or args.target == "app":
    build_app(APP_DIR_PATH, True)

if args.target == "all" or args.target == "cordova":
    # For tsc
    TSC_PATH= APP_DIR_PATH + '/node_modules/typescript/bin'
    os.environ["PATH"]=os.environ["PATH"] + ":" + TSC_PATH

    ela_plugin.plugin_prepare(True)

    # print_with_color(bcolors.OKGREEN, 'Build platform:'), build_platform
    # ela_xml.update_xml(RUNTIME_DIR_PATH + '/config.xml', build_platform)
    # updatePackageJson(RUNTIME_DIR_PATH + '/package.json', build_platform)

    run_cmd("cordova prepare")

    # if "electron" in build_platform:
    #     #ela_plugin.install_electron()
    #     ela_plugin.copy_electron_files()
    #     ela_plugin.install_titlebar()
    #     os.chdir(ELECTRON_TITLEBAR_DIR_PATH)
    #     copy_tree("www", RUNTIME_DIR_PATH + "/www/shared-titlebar")
    #     os.chdir(RUNTIME_DIR_PATH)
    #     copy_tree("plugin_src", "www/plugin_src")
    #     run_cmd("cordova prepare")

    #     print("'cd Runtime/platforms/electron/www', to start in dev mode -> enter:")
    #     print("windows: 'electron .'")
    #     print("ubuntu: 'sudo electron --no-sandbox .'")

    add_firebase()

    if args.build:
        if "android" in build_platform:
            # TODO: Need set the ANDROID_NDK_HOME
            run_cmd("cordova build android " + build_type + " " + build_arg)
        if "electron" in build_platform:
            run_cmd("cordova build electron " + build_type + " " + build_arg)
        if "ios" in build_platform:
            run_cmd("cordova build ios " + build_type + " " + build_arg)


elapsed = timeit.default_timer() - startTime
minutes = elapsed / 60
seconds = elapsed % 60
print_with_color(bcolors.OKGREEN, 'elapsed time [%d min %0.2fs]' % (minutes, seconds))
